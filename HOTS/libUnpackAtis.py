#!/usr/bin/python
# -*- coding: utf8 -*#################
# unpackAtis.py #
#################
# Feb 2017 - Jean-Matthieu Maro
# Email: jean-matthieu dot maro, hosted at inserm, which is located in FRance.
# Thanks to Germain Haessig for his code snippets (in peek and readATIS_td).

from struct import unpack, pack
import numpy as np
import matplotlib.pyplot as plt
import matplotlib.animation as animation
from matplotlib.colors import LinearSegmentedColormap
from colorama import init, Fore, Back, Style
init()

def peek(f, length=1):
    pos = f.tell()
    data = f.read(length)
    f.seek(pos)
    return data

def readATIS_td(file_name, orig_at_zero = True, drop_negative_dt = True, verbose = True):

    """ read and load _td.dat files generated by kAER """

    if verbose:
        print('Reading _td dat file... (' + file_name + ')')
    file = open(file_name,'rb')

    header = False
    while peek(file) == b'%':
        file.readline()
        header = True
    if header:
        ev_type = unpack('B',file.read(1))[0]
        ev_size = unpack('B',file.read(1))[0]
        if verbose:
            print('> Header exists. Event type is ' + str(ev_type) + ', event size is ' + str(ev_size))
        if ev_size != 8:
            print('Wrong event size. Aborting.')
            return -1, -1, -1, -1
    else: # set default ev type and size
        if verbose:
            print('> No header. Setting default event type and size.')
        ev_size = 8
        ev_type = 0

    # Compute number of events in the file
    start = file.tell()
    file.seek(0,2)
    stop = file.tell()
    file.seek(start)

    Nevents = int( (stop-start)/ev_size )
    if verbose:
        print("> The file contains %d events." %Nevents)

    # store read data
    timestamps = np.zeros(Nevents, dtype = int)
    polarities = np.zeros(Nevents, dtype = int)
    coords = np.zeros((Nevents, 2), dtype = int)

    for i in np.arange(0, int(Nevents)):

        event = unpack('Q',file.read(8))
        ts = event[0] & 0x00000000FFFFFFFF
        # padding = event[0] & 0xFFFC000000000000
        pol = (event[0] & 0x0002000000000000) >> 49
        y = (event[0] & 0x0001FE0000000000) >> 41
        x = (event[0] & 0x000001FF00000000) >> 32

        timestamps[i] = ts
        polarities[i] = pol
        coords[i, 0] = x
        coords[i, 1] = y

    file.close()

    if verbose:
        print("> Sequence duration: %ds" %float((timestamps[-1] - timestamps[0]) / 1e6))

    #check for negative timestamps
    for ts in timestamps:
        if ts < 0:
            print('prout negative delta-ts')

    if orig_at_zero:
        timestamps = timestamps - timestamps[0]

    if drop_negative_dt:
        if verbose:
            print('> Looking for negative dts...')
        # first check if negative TS differences
        index_neg = np.zeros(0)
        ii = 0
        while ii < (timestamps.size - 1):
            dt = timestamps[ii+1] - timestamps[ii]
            if dt < 0:  # alors ts en ii+1 plus petit que ii
                index_neg = np.append(index_neg, ii+1)
                ii += 1
            ii += 1

        timestamps = np.delete(timestamps, index_neg)
        polarities = np.delete(polarities, index_neg)
        coords = np.delete(coords, index_neg, axis = 0)
        if verbose:
            print('> Removed %d events.' %index_neg.size)
        removed_events = index_neg.size
    else:
        removed_events = -1

    return timestamps, coords, polarities, removed_events

def writeATIS_td(file_name, ts, coords, pol):
    """ writes _td.dat files like the ones generated by kAER """

    print('Writing td dat file... (' + file_name + ')')

    file = open(file_name,'wb')

    # write header
    headerstr = '% HEADER: td style file generated from phone ATIS dump. V0.1\n'
    file.write(headerstr.encode('ascii'))

    # write event type and size
    file.write(pack('B', 0))
    file.write(pack('B', 8))

    # write events
    for i in np.arange(0, ts.size):

        binevent = (int(ts[i]) & 0x00000000FFFFFFFF) + ((int(pol[i]) << 49) & 0x0002000000000000) + ((int(coords[i, 0]) << 32) & 0x000001FF00000000) + ((int(coords[i, 1]) << 41) & 0x0001FE0000000000)

        file.write(pack('Q', binevent))

    file.close()

def readATISdump(file_name, orig_at_zero = True, drop_negative_dt = True):

    """ Read .dat binary files which are direct dumps of the ATIS USB stream.
    (not kAER _td.dat files)
    Event format is of the CCAM2, the small footprint ATIS used in ECOMODE.

    Beware: this function only returns LEFT_TD_LOW and LEFT_TD_HIGH events.
    NO APS. NO STEREO.

    Each event is of size 32 bits (or 4 bytes).
    The enclosed information depends on the event type. See doc. """

    print('Reading USB dump dat file... (' + file_name + ')')

    # Types of events outputed by the ATIS
    LEFT_TD_LOW     = 0
    LEFT_TD_HIGH    = 1
    LEFT_APS_START  = 2
    LEFT_APS_END    = 3
    RIGHT_TD_LOW    = 4
    RIGHT_TD_HIGH   = 5
    RIGHT_APS_END   = 6
    RIGHT_APS_START = 7
    EVT_TIME_HIGH   = 8
    STEREO_DISP     = 9
    ORIENTATION     = 13
    CONTINUED       = 15

    # File to read from
    file = open(file_name,'rb')
    ev_size = 4     # events have size 4 bytes (32 bits)

    # Compute number of events in the file
    start = file.tell()
    file.seek(0,2)
    stop = file.tell()
    file.seek(start)
    Nevents = int((stop-start)/ev_size)
    print("> The file contains %d events." %Nevents)

    # Store read data
    timestamps = np.zeros(Nevents, dtype = int)
    polarities = np.zeros(Nevents, dtype = int)
    coords = np.zeros((Nevents, 2), dtype = int)

    no_index_events = 0 # number count of EVT_TIME_HIGH and unneeded events.
    no_EVT_TIME_HIGH_yet = True  # was a EVT_TIME_HIGH event received yet?
    cpt = 0 # index where to store the event
    for ev in np.arange(Nevents):
        # read ev_size bytes
        data = unpack('<I', file.read(ev_size))[0]
        # decode the type of the event
        ev_type = (data & 0xF0000000) >> 28 # event type is bits 31..28
        store_event = False # does the event have to be stored in the vector?
        if ev_type == EVT_TIME_HIGH:
            no_index_events += 1
            no_EVT_TIME_HIGH_yet = False
            ts_MSB = (data & 0x0FFFFFFF) << 11  # MSB of the timestamp, shifted by 11 bits to make room for the LSB of the timestamp

        elif ev_type == LEFT_TD_LOW:
            store_event = True
            y = data & 0x000000FF           # y is bits 7..0
            x = (data & 0x0001FF00) >> 8    # x is bits 18..8
            ts_LSB = (data & 0x0FFE0000) >> 17  # ts is bits 27..17
            p = 0                           # pol is 0 (LOW type)
        elif ev_type == LEFT_TD_HIGH:
            store_event = True
            y = data & 0x000000FF           # y is bits 7..0
            x = (data & 0x0001FF00) >> 8    # x is bits 18..8
            ts_LSB = (data & 0x0FFE0000) >> 17  # ts is bits 27..17
            p = 1                           # pol is 1 (HIGH type)
        else:   # APS, RIGHT_, STEREO, ORIEN, CONTI events are not needed.
            no_index_events += 1
            # print('Not interested in this event type (', ev_type, ')')

        if no_EVT_TIME_HIGH_yet:
            no_index_events += 1
            store_event = False

        if store_event:
            timestamps[cpt] = ts_MSB + ts_LSB
            polarities[cpt] = p
            coords[cpt, 0] = x
            coords[cpt, 1] = y
            cpt += 1

    file.close()

    if cpt != (Nevents - no_index_events):
        print('> Something might have gone wrong.')

    if orig_at_zero:
        timestamps = timestamps - timestamps[0]

    timestamps = timestamps[0:cpt]
    coords = coords[0:cpt, :]
    polarities = polarities[0:cpt]

    print("> Sequence duration: %ds" %float((timestamps[-1] - timestamps[0]) / 1e6))

    if drop_negative_dt:
        print('> Looking for negative dts...')
        # first check if negative TS differences
        index_neg = np.zeros(0)
        for ii in np.arange(timestamps.size - 1):
            dt = timestamps[ii+1] - timestamps[ii]
            if dt < 0:  # alors ts en ii+1 plus petit que ii
                if (timestamps[ii+2] - timestamps[ii]) > 0:
                    index_neg = np.append(index_neg, ii+1)
                else:
                    print('> not cool. double jump negative dt.')

        timestamps = np.delete(timestamps, index_neg)
        polarities = np.delete(polarities, index_neg)
        coords = np.delete(coords, index_neg, axis = 0)
        print('> Removed %d events.' %index_neg.size)
        removed_events = index_neg.size
    else:
        removed_events = -1

    return timestamps, coords, polarities, removed_events

def plotHistogramAndMeansForDeltaTs(timestamps, max_dt = 5000, time_window = 1000, fignumbers =[1, 2, 3], my_dpi = 96, figpixsize = [1400, 800], savename = 'noname', show_plots = False, dt_too_high = 1000):

    """ plot statistics about the current timestamps """

    print(Fore.MAGENTA + "Means and histogram..." + Style.RESET_ALL)
    # 2/ stats about dt
    # 2a/ histogram of dts
    print("Computing deltaTs between consecutive events...")
    dts = np.zeros(timestamps.size - 1)
    index_gap_max_dt = []
    for ii in np.arange(timestamps.size - 1):
        dts[ii] = timestamps[ii+1] - timestamps[ii]
        if dts[ii] > max_dt:
            index_gap_max_dt.append(ii)
    max_obs_dt = np.max(dts)

    # # 2b/ number of events per ms
    # # "instantaneous" mean
    print("No-overlap mean number of events...")
    curr_dt = 0
    ev_count = 0
    events_per_ms = []
    index_segmented = []
    for ii in np.arange(dts.size):
        if (curr_dt + dts[ii]) > time_window:
            events_per_ms.append(ev_count)
            index_segmented.append(ii - ev_count)
            curr_dt = dts[ii]
            ev_count = 1
        else:
            curr_dt += dts[ii]
            ev_count += 1
    # "moving mean"
    print("Moving mean number of events...")
    curr_dt = 0
    ev_count = 0
    events_per_ms_moving = []
    ii = 0
    index_moving = []
    while ii < (dts.size - 1):
        index_moving.append(ii)
        s = 0
        while (curr_dt + dts[ii+s]) < time_window:
            curr_dt += dts[ii+s]
            ev_count += 1
            s += 1
            if (ii+s) > (dts.size - 1):
                break
        events_per_ms_moving.append(ev_count)
        ii += np.floor(ev_count/2) + 1
        curr_dt = 0
        ev_count = 0

    # plot dts
    print("Figures...")
    plt.figure(fignumbers[0], figsize = (figpixsize[0] / my_dpi, figpixsize[1] / my_dpi), dpi = my_dpi)
    if max_obs_dt < 5000:
        histobins = [0, 5, 10, 50, 100, 500, 1000, 5000]
    else:
        histobins = [0, 5, 10, 50, 100, 500, 1000, 5000, max_obs_dt + 1]
    count, bins = np.histogram(dts, bins = histobins)
    bar_width = 1
    index = np.arange(count.size)
    rects = plt.bar(index, count, bar_width, color = 'green')
    labels = ["%d" % i for i in count]
    for rect, label in zip(rects, labels):
        height = rect.get_height()
        plt.gca().text(rect.get_x() + rect.get_width()/2, height + 5, label, ha='center', va='bottom')
    plt.yscale('log', nonposy='clip')
    dt_ticks = ["%d to %d µs" %(j,i) for i,j in zip(histobins[1:], histobins[:-1])]
    plt.xticks(index + bar_width / 2, dt_ticks)
    plt.xlabel('delta T from...')
    plt.ylabel('event count (logscale)')
    plt.title('Histogram of the time difference (delta T) between two consecutive timestamps\n(max deltaT is ' + str(max_obs_dt) + 'µs)')
    plt.savefig(savename + '_hist.png', dpi=my_dpi)
    # plot events per ms
    plt.figure(fignumbers[1], figsize = (figpixsize[0] / my_dpi, figpixsize[1] / my_dpi), dpi = my_dpi)
    plt.plot(timestamps[index_segmented], events_per_ms,'bo-', fillstyle = "none", label = "no-overlap mean")
    plt.plot(timestamps[index_moving], events_per_ms_moving,'r*-', label = "moving mean")
    # verticalbar = [0, np.max(events_per_ms)]
    # for gap in timestamps[index_gap_max_dt]:
    #     plt.plot([gap, gap], verticalbar, 'g-')
    plt.legend()
    plt.title('Mean event count for a 1 ms time-window')
    plt.ylabel('mean event count')
    plt.xlabel('time (µs)')
    plt.savefig(savename + '_means.png', dpi=my_dpi)
    # plot timestamps
    plt.figure(fignumbers[2], figsize = (figpixsize[0] / my_dpi, figpixsize[1] / my_dpi), dpi = my_dpi)
    plt.plot(timestamps, np.arange(timestamps.size),'r.', fillstyle = "none")
    verticalbar = [0, timestamps.size]
    for gap in timestamps[index_gap_max_dt]:
        plt.plot([gap, gap], verticalbar, 'g-')
    plt.title('Timestamps. Vertical bars when no event occured for more than' + str(max_dt / 1000) + ' ms')
    plt.ylabel('index')
    plt.xlabel('time (µs)')
    plt.savefig(savename + '_ts.png', dpi=my_dpi)

    if show_plots:
        plt.show()
    for ii in fignumbers:
        plt.figure(ii).clf()
        plt.close(ii)

def displayStreamOfEvents(timestamps, coords, polarities, time_window = 1000, fignumber = 4):

    """ compute and then display frames from an event stream """

    print("Display, generating frames...")
    # compute dts
    dts = np.zeros(timestamps.size - 1)
    for ii in np.arange(timestamps.size - 1):
        dts[ii] = timestamps[ii+1] - timestamps[ii]

    # compute index_segmented
    curr_dt = 0
    ev_count = 0
    # events_per_ms = []
    index_segmented = []
    for ii in np.arange(dts.size):
        if (curr_dt + dts[ii]) > time_window:
            # events_per_ms.append(ev_count)
            index_segmented.append(ii - ev_count)
            curr_dt = dts[ii]
            ev_count = 1
        else:
            curr_dt += dts[ii]
            ev_count += 1

    # generate frames for the display
    jjindexes =  np.arange(1, len(index_segmented) - 1, 10)
    max_frame = jjindexes.size
    frames = np.zeros((240, 304, max_frame))
    t = 0
    cpt = 0
    polarities[polarities == 0] = -1
    for jj in jjindexes:
        ii = index_segmented[jj]
        display = np.zeros((240, 304))
        while cpt < ii:
            display[coords[cpt, 1], coords[cpt, 0]] = polarities[cpt]
            cpt += 1
        frames[:,:,t] = display
        t += 1

    fig = plt.figure(fignumber)
    fig.canvas.set_window_title('ATIS Display')
    im = plt.imshow(frames[:,:,0], interpolation="none", cmap = plt.cm.gray, vmin = -1, vmax = 1)
    title = plt.title("")

    def update(t):
        im.set_data(frames[:,:,t])
        title.set_text(str(t))

    ani = animation.FuncAnimation(fig, func=update, frames=max_frame, repeat=False, interval=10)
    plt.show()

def displayFrames(frames, fignumber = 4):

    """ display provided frame array """

    fig = plt.figure(fignumber)
    fig.canvas.set_window_title('ATIS Display')
    im = plt.imshow(frames[:,:,0], interpolation="none", cmap = plt.cm.gray, vmin = -1, vmax = 1)
    #title = plt.title("")
    plt.xticks([], [])
    plt.yticks([], [])

    max_frame = frames.shape[2]

    def update(t):
        im.set_data(frames[:,:,t])
        #title.set_text(str(t))

    ani = animation.FuncAnimation(fig, func=update, frames=max_frame, repeat=False, interval=10)
    plt.show()

def generateFramesFromStreamOfEvents(timestamps, coords, polarities, time_window = 1000):

    """ returns a frame array from a stream of event. can be then displayed using the displayFrames function """

    print("Generating frames...")
    # compute dts
    dts = np.zeros(timestamps.size - 1)
    for ii in np.arange(timestamps.size - 1):
        dts[ii] = timestamps[ii+1] - timestamps[ii]

    # compute index_segmented
    curr_dt = 0
    ev_count = 0
    # events_per_ms = []
    index_segmented = []
    for ii in np.arange(dts.size):
        if (curr_dt + dts[ii]) > time_window:
            # events_per_ms.append(ev_count)
            index_segmented.append(ii - ev_count)
            curr_dt = dts[ii]
            ev_count = 1
        else:
            curr_dt += dts[ii]
            ev_count += 1

    # generate frames for the display
    jjindexes =  np.arange(1, len(index_segmented) - 1, 10)
    max_frame = jjindexes.size
    frames = np.zeros((240, 304, max_frame))
    t = 0
    cpt = 0
    polarities[polarities == 0] = -1
    for jj in jjindexes:
        ii = index_segmented[jj]
        display = np.zeros((240, 304))
        while cpt < ii:
            display[coords[cpt, 1], coords[cpt, 0]] = polarities[cpt]
            cpt += 1
        frames[:,:,t] = display
        t += 1
    print('> Done, ready to display')
    return frames


def denoise(ts, coords, min_dt = 1000, radius = 1, min_ev = 1):

    """ activity noise filter. returns a bool list of events to keep """

    print('Activity-denoising...')
    recent_events = np.zeros((304,240), dtype = int)
    keepers = np.zeros(ts.size, dtype = bool)
    for ii in np.arange(1, ts.size):
        x, y = coords[ii,0], coords[ii,1]
        recent_events[x, y] = ts[ii]
        # neighbors = recent_events[x-1:x+2, y-1:y+2]
        # if np.sum(((ts[ii] - neighbors) < min_dt)) > 1:
        #     print("spike!")
        # else:
        #     print("no!")
        keepers[ii] = np.sum(((ts[ii] - recent_events[x-radius:x+radius+1, y-radius:y+radius+1]) < min_dt)) > min_ev
    print("> To be removed:",  (ts.size - np.sum(keepers)), "events. (~", int(100.0 * float(ts.size - np.sum(keepers)) / float(ts.size)), "%)")
    return keepers

def remove_crazy_pixels(ts, coords, crazypix):
    print('Removing crazy pixels...')
    keepers = np.ones(ts.size, dtype = bool)
    prog_steps = int(ts.size / 4)
    for ii in np.arange(ts.size):
        if (ii % prog_steps == 0):
            print('> Progress: ~', int(round(ii / ts.size * 100)), '%')
        for pix in crazypix:
            if (coords[ii,:] == pix).all():
                keepers[ii] = False
                break
    print("> To be removed:",  (ts.size - np.sum(keepers)), "events. (~", int(100.0 * float(ts.size - np.sum(keepers)) / float(ts.size)), "%)")
    return keepers

def displayFramesColorPol(frames, myvmin = -1, myvmax = 1, frameinterval = 10):
    # fig = plt.figure(fignumber)
    fig, ax = plt.subplots()
    fig.canvas.set_window_title('ATIS Display')

    #custom colormap
    # black, red, orange,...
    colors = [(0.5, 0.5, 0.5), (1, 0, 0), (0, 0.5, 0), (1, 0.5, 0), (1, 1, 0), (0, 1, 0), (0, 1, 1), (1, 1, 1), (1, 0, 1), (0, 0, 0), (0, 0, 1)]

    # colors = [(0.5, 0.5, 0.5), (1, 0, 0), (0.3, 0.6, 0), (1, 0.5, 0), (1, 1, 0), (0, 1, 0), (0, 1, 1), (1, 1, 1), (1, 0, 1), (0, 0, 0), (0.5, 0.5, 0.5)]
    cm = LinearSegmentedColormap.from_list('flow', colors, N=len(colors))
    im = ax.imshow(frames[:,:,0], interpolation="none", cmap = cm, vmin = myvmin, vmax = myvmax)
    #title = plt.title("")
    plt.xticks([], [])
    plt.yticks([], [])

    # colorbar
    cbar = fig.colorbar(im, ticks=np.arange(myvmin+1, myvmax+1))
    cbar.ax.set_yticklabels(np.arange(myvmin, myvmax))

    max_frame = frames.shape[2]
    def update(t):
        im.set_data(frames[:,:,t])
        #title.set_text(str(t))

    ani = animation.FuncAnimation(fig, func=update, frames=max_frame, repeat=True, interval=frameinterval)

    plt.show()
